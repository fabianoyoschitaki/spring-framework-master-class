What are the beans?
What are the dependencies of a bean?
Where to search for beans? => No need as SpringBootApplication scans package and subs

@Component (beans)
@Autowired (dependency)
@Primary (disambiguous component)

Older versions of Spring:
Setter Injection -> if dependency is optional
Constructor Injection -> if dependency is mandatory

You don't need a setter with the @Autowired, the value is set by reflection.
You can also autowire by name

@Autowired
@Primary
private SortAlgorithm sortAlgorithm;

@Autowired
private SortAlgorithm bubleSortAlgorithm;

@Primary has priority over the bean name.
------------------------------------------------------------------------------
20 - Autowiring in depth - @Qualifier annotation
	Another way is put
	@Qualifier both in the dependency class and the class which has the dependency. @Qualifier has priority over @Primary!
	use @Primary if you have a more efficient algorithm among all. In case you have to switch to the other one, you can use autowiring by name or @Qualifier.
------------------------------------------------------------------------------
21 - Scope of a bean - Prototype and Singleton
	Bean Scope (default singleton)
	- singleton: One instance per Spring Context
	- prototype: New bean whenever requested
	- request: One bean per HTTP request
	- session: One bean per HTTP session
------------------------------------------------------------------------------
22 - Complex Scope Scenarios of a Spring Bean - Mix Prototype and Singleton
	if PersonDAO is singleton and has JdbcConnection is prototype as dependency, the same jdbcConnection object will be returned. 
	So you have to create a proxy
	@Scope(value=ConfigurableBeanFactory.SCOPE_PROTOTYPE, proxyMode=ScopedProxyMode.TARGET_CLASS)
------------------------------------------------------------------------------
23 - Difference between Spring Singleton and GOF Singleton
	GOF - 1 instance per JVM, even if multiple applications are running in the same JVM, the same instance would be returned. 
	Spring - 1 instance per application context. If there are 5 application contexts in the same JVM, 5 different instances.
------------------------------------------------------------------------------	
24 - Using Component Scan to scan for beans
	if you application is com.test, every sub package will be scanned for components.
	But if you have components say in com.abc, you have to add in the spring application:
	@ComponentScan("com.abc")
------------------------------------------------------------------------------	
25 - Lifecycle of a Bean @PostConstruct and @PreDestroy (callback methods)
	when put @Component, the lifecycle of a bean is going to be managed by the spring IOC container.
	if you want to do certain things before being destroyed or after it was created;
	One of the first things that the IOC container does is autowire the dependencies. Then, call 
	@PostConstruct method after that. The @PreDestroy is similar, but it happens when the instance
	is in the process of being removed by the container. 
------------------------------------------------------------------------------
26 - Container and Dependency Injection (CDI)
	Java EE Dependency Injection Standard (JSR 330)
	Spring supports most annotations:
		@Inject (@Autowired)
		@Named (@Component & @Qualifier)
		@Singleton (defined a scope of Singleton)
	Similar to JPA and Hibernate, interface and implementation, CDI defines how to do dependency injection. 
	In order to use CDI, add to pom.xml, below spring-boot-starter:
	<dependency>
		<groupId>javax.inject</groupId>
		<artifactId>javax.inject</artifactId>
		<version>1</version>
	</dependency>
	
	When use CDI annotations or Spring annotations? CDI is a Java EE standard. You'd always stick to a standard, 
	like JPA instead of Hibernate. There's actually no good reasons why use one over each other... :P 
	Btw CDI offers really good flexibility tomorrow if you want to switch away from Spring as Dependency Injection Framework.
------------------------------------------------------------------------------	
27 - Ignore SLF4J Errors in Step 19 - We will fix them in Step 20 
	As we start removing Spring Boot and bringing in Spring core in the next step, you would see
	
	A few SLF4J errors.
	Logging does not work
	Do not worry about them. We will fix them in Step 20.
------------------------------------------------------------------------------	
28 - Removing Spring Boot in Basic Application
	How to use Spring without Spring Boot? Let's remove spring boot starter.  
	Change in pom.xml:
	<dependency>
		<groupId>org.springframework.boot</groupId>
		<artifactId>spring-boot-starter</artifactId>
	</dependency>
	to
	<dependency>
		<groupId>org.springframework</groupId>
		<artifactId>spring-core</artifactId>
	</dependency>

	<dependency>
		<groupId>org.springframework</groupId>
		<artifactId>spring-context</artifactId>
	</dependency>
	if you run SpringIn5StepsBasicApplication, you'll get an error because spring boot is not available when running.
	The reason why there are no compile errors is because:
	<dependency>
		<groupId>org.springframework.boot</groupId>
		<artifactId>spring-boot-starter-test</artifactId>
		<scope>test</scope>
	</dependency>
	which we will remove later.
	
	The first thing to get rid of this error is to initialize Application Context: 
		Change @SpringBootApplication to @Configuration (org.springframework.context.annotation.Configuration)
	
	Also, SpringApplication is from spring boot. 
		Change ApplicationContext applicationContext = SpringApplication.run(SpringIn5StepsBasicApplication.class, args);
		to ApplicationContext applicationContext = new AnnotationConfigApplicationContext(SpringIn5StepsBasicApplication.class);
		
	The other change is that we have to scan the package (which spring boot does by default)
		@ComponentScan("") or declare the package explicitly.
	
	We will get Caused by: java.lang.ClassNotFoundException: org.slf4j.LoggerFactory, so we add in pom.xml:
		<dependency>
			<groupId>org.slf4j</groupId>
			<artifactId>slf4j-api</artifactId>
		</dependency>
------------------------------------------------------------------------------
29 - Fixing minor stuff - Add Logback and Close Application Context
	We have to close the application context:
		from ApplicationContext applicationContext = new AnnotationConfigApplicationContext(SpringIn5StepsBasicApplication.class);
		to ApplicationContext applicationContext = new AnnotationConfigApplicationContext(SpringIn5StepsBasicApplication.class);
		
		applicationContext.close();
		
	Another way would be using Java 7 feature:
		try (AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext(
				SpringIn5StepsBasicApplication.class)) {
				
	The log wasn't working properly. This is because we added the slf4j-api but not the implementation. Let's use logback which Spring uses by default:
		SLF4J: Failed to load class "org.slf4j.impl.StaticLoggerBinder".
		SLF4J: Defaulting to no-operation (NOP) logger implementation
		SLF4J: See http://www.slf4j.org/codes.html#StaticLoggerBinder for further details.
	
	The implementation:
		<!-- SLF4J implementation -->
		<dependency>
			<groupId>ch.qos.logback</groupId>
			<artifactId>logback-classic</artifactId>
		</dependency>
------------------------------------------------------------------------------
30 - Defining Spring Application Context Using XML - Part 1
	Duplicate com.fabiano.spring.basics.springin5steps.scope classes to com.fabiano.spring.basics.springin5steps.xml
		- XMLJdbcConnection and XMLPersonDAO
		- remove annotations @Component and @Scope(ConfigurableBeanFactory.SCOPE_SINGLETON)
	
	Before Spring 2.5, all these things had to be wired manually through XML:
		- Create new xml file applicationContext.xml in src/main/resources. Copy content from https://docs.spring.io/spring/docs/3.0.x/spring-framework-reference/html/beans.html:
			<?xml version="1.0" encoding="UTF-8"?>
			<beans xmlns="http://www.springframework.org/schema/beans"
				   xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
				   xsi:schemaLocation="http://www.springframework.org/schema/beans
					   http://www.springframework.org/schema/beans/spring-beans-3.0.xsd">

			  <bean id="..." class="...">
				<!-- collaborators and configuration for this bean go here -->
			  </bean>

			  <bean id="..." class="...">
				<!-- collaborators and configuration for this bean go here -->
			  </bean>

			  <!-- more bean definitions go here -->

			</beans>
		
		- Create the beans
			<bean id="xmlJdbcConnection" 
				class="com.fabiano.spring.basics.springin5steps.xml.XmlJdbcConnection">
			</bean>

			<bean id="xmlPersonDAO" 
				class="com.fabiano.spring.basics.springin5steps.xml.XmlPersonDAO">
			</bean>
			
		- Wire the beans 
			<bean id="xmlPersonDAO" 
				class="com.fabiano.spring.basics.springin5steps.xml.XmlPersonDAO">
				<property name="xmlJdbcConnection" ref="xmlJdbcConnection"/>
			</bean>
------------------------------------------------------------------------------
31 - Defining Spring Application Context Using XML - Part 2
	Created SpringIn5StepsXMLContextApplication.java
	Now, to load the beans using applicationContextXML:
		try (ClassPathXmlApplicationContext applicationContext = 
			new ClassPathXmlApplicationContext("applicationContext.xml")) {
			XmlPersonDAO personDao = applicationContext.getBean(XmlPersonDAO.class);
			System.out.println(personDao);
			System.out.println(personDao.getXmlJdbcConnection());
		}
		
	Before annotations, it was really difficult to wire beans using Spring. 
------------------------------------------------------------------------------
32 - Mixing XML Context with Component Scan for Beans defined with Annotations
	In SpringIn5StepsXMLContextApplication.java, there is no need to use @Component and @Configuration, because it is based on XML. 
	Let's check which beans are being loaded:
		LOGGER.info("Beans Loaded -> {}", (Object)applicationContext.getBeanDefinitionNames());
		Beans Loaded -> [xmlJdbcConnection, xmlPersonDAO]
		
	These 2 beans are the ones which we have defined in the applicationContext.xml.
	What if we want to load other beans? (basic, cdi and scope packages)
	A: Component Scan in applicationContext.xml:
	
		<beans xmlns="http://www.springframework.org/schema/beans"
			xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
			xmlns:context="http://www.springframework.org/schema/context"
			xsi:schemaLocation="http://www.springframework.org/schema/beans
							   http://www.springframework.org/schema/beans/spring-beans-3.0.xsd
							   http://www.springframework.org/schema/context
							   http://www.springframework.org/schema/context/spring-context-3.0.xsd">

			<context:component-scan base-package="com.fabiano.spring.basics"></context:component-scan>
		Beans Loaded -> [componentDAO, scopedTarget.componentJdbcConnection, componentJdbcConnection, 
						 binarySearchImpl, bubbleSortAlgorithm, quickSortAlgorithm, someCdiBusiness, someCdiDao, 
						 scopedTarget.jdbcConnection, jdbcConnection, personDAO, springIn5StepsBasicApplication, 
						 springIn5StepsCdiApplication, springIn5StepsComponentScanApplication, springIn5StepsScopeApplication, 
						 org.springframework.context.annotation.internalConfigurationAnnotationProcessor, 
						 org.springframework.context.annotation.internalAutowiredAnnotationProcessor, 
						 org.springframework.context.annotation.internalRequiredAnnotationProcessor, 
						 org.springframework.context.annotation.internalCommonAnnotationProcessor, 
						 org.springframework.context.event.internalEventListenerProcessor, 
						 org.springframework.context.event.internalEventListenerFactory, 
						 xmlJdbcConnection, xmlPersonDAO]
	
	So here we are using a combination of defining beans and component scan. To remove both beans in applicationContext.xml, 
	add to XmlPersonDAO.java: @Component to class and @AutoWired to XmlJdbcConnection attribute
	add to XmlJdbcConnection.java: @Component to class

------------------------------------------------------------------------------
33 - IOC Container vs Application Context vs Bean Factory
	DISAMBIGUATION:
		- IOC Container: Let's say WelcomeController needs WelcomeService. WC directly creates an instance of WS 
			@RestController
			public class WelcomeController {
				private WelcomeService service = new WelcomeService(); 
			
			But when using Spring, then we would do this:
				@RestController
				public class WelcomeController {
					@AutoWired
					private WelcomeService service; 
					
				@Component
				public class WelcomeService
			
			Who does that? Spring Framework. It shifts the responsibility of creating the bean out to spring. 
			The control moves out of the controller or the component which needs the dependency to the framework which is injecting the dependency in. 
			The program that provides inversion of control is the IOC container. Manage, create, autowire beans. 
			In Spring, there are two implementations of the IOC Container: Application Context and Bean Factory. In all scenarios we've been using
			Application Context because Spring recommend to use it in 99% of the scenarios, except when memory is a premmium (like an IOT device)
			
			What is the difference between Application Context and Bean Factory? AC is nothing but Bean Factory ++
			INCOMPLETO... 3:10
				
		
		- Application Context (second one of the two implementations of the IOC container)
			It is BeanFactory++: Spring's AOP features, internationalization, WebApplicationContext for web applications etc

		- Bean Factory (first one of the two implementations of the IOC container)
			It only provides the basic management for the beans and wiring of dependencies, nothing more.
------------------------------------------------------------------------------
34 - @Component vs @Service vs @Repository vs @Controller
	These are the different stereotypes that are present in Spring.	Talking about web applications:

		Web Layer/UI Layer - shows information to the user
		Business Layer - responsible for the business logic 
		Data Layer - responsible for getting the data from the database or an external interface		

	@Component: Generic Component. If you're not sure if something belongs to one of those layers, then you can use @Component.
	
	The other 3 annotations are very specific:
		@Repository: Encapsulating storage, retrieval, and search behavior typically from a relational database. (Data Layer)
		@Service: Business Service Facade. (Business Layer)
		@Controller: Controller in MVC Pattern. (Web Layer)
	
	So let's change PersonDAO and ComponentDAO to @Repsitory 
	and BinarySearchImpl, BubbleSortAlgorithm, QuickSortAlgorithm and SortAlgorithm to @Service (Business!)

	This does not change the functionality. So why should I use a specific annotation. In the AOP section, you'll see you can add
	different functionalities by putting them in different categories and apply different logic for each of these categories. 
	For example, Spring provides a default exception translation facility if you use Repository. There are lots of JDBC Exceptions, so if you put this @Repository, Spring translates them, if you put @Component you will not be able to use that feature. 
	Also, let's suppose you want to log everything that is in your Business Layer. In that kind of scenario, you would have to identity everything that has an @Service annotation and use AOP and log everything. (We'll talk about that in the AOP section) 
------------------------------------------------------------------------------
35 - Read values from external properties file
	Typically applications have a lot of configuration. For example, in the data layer, you might be talking to a database. So this configuration might be different in different environments. Also, the external services that you talk to might be different in different environments. 
	So these kind of values are good to be externalized into property file. 
	
	1. Let's create com.fabiano.spring.basics.springin5steps.properties class SomeExternalService:
		
		@Component
		public class SomeExternalService {
	
			//from property file
			private String url;
	
			public String returnServiceURL() {
				return this.url;
			}
		}

	2. at src/main/resources, create app.properties file: 
		
		external.service.url=http://someserver.dev.com/service

	3. Go back to SomeExternalService and put: 
		
		@Value("${external.service.url}")
		private String url;

	4. To load the app.properties, create a new class SpringIn5StepsPropertiesApplication (@PropertySource("classpath:app.properties")):
		@Configuration
		@ComponentScan
		//load app.properties
		@PropertySource("classpath:app.properties")
		public class SpringIn5StepsPropertiesApplication {

			public static void main(String[] args) {
				try (AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext(
						SpringIn5StepsPropertiesApplication.class)) {

					SomeExternalService service = applicationContext.getBean(SomeExternalService.class);
					System.out.println(service);
				}
			}
		}
------------------------------------------------------------------------------
SECTION 5 - BASIC TOOLS AND FRAMEWORKS - JUNIT IN 5 STEPS
------------------------------------------------------------------------------
36 - Section Introduction - JUnit in 5 Steps
	@Before, @After, @BeforeClass etc...
	Code in: https://github.com/in28minutes/spring-master-class/tree/master/00-framework-tool-introductions/03.JUnit-Introduction-In-5-Steps

------------------------------------------------------------------------------
37 - Step 1: What is JUnit and Unit Testing
	Unit Testing is testing a specific code or a class, for the methods of the class. JUnit is a framework that will help you call these methods and check whether the output is as expected. One advantage of using JUnit is that it is automated, running every hour or whenever any change happen, being notified. JUnits can be run in Continuous Integrations like Jenkins. 
	Unit Testing falls under the suit of Automation Testing. The important thing about automation testing is that these can be run under continuous integration. 

------------------------------------------------------------------------------
38 - Step 2: First JUnit Project and Green Bar
	Create new Java Project junit-in-5-steps and class in package com.fabiano.junit;

		public class MyMath {
			int sum (int[] numbers) {
				int sum = 0;
				for (int n : numbers) {
					sum+=n;
				}
				return sum;
			}
		}
	How can we be sure that this method is working fine?
	Let's create a source folder of tests (Unit tests should be in a different folder compared to Production code! The test code must not be deployed)
		new source folder "test"
	Then create new JUnit Test Case (New JUnit 4 test) MyMathTest. In JUnit, absence of failure is success, be careful.

------------------------------------------------------------------------------
39 - Step 3: First Code and First Unit Test
	Let's test the MyMath.sum in the JUnit test case we previously created. Create method:
	
	public class MyMathTest {
	
		MyMath myMath = new MyMath();
	
		@Test
		public void sumWith3Numbers() {
			//check that result is 6
			assertEquals(6, myMath.sum(new int[] {1,2,3}));
		}
	
		@Test
		public void sumWith1Number() {
			assertEquals(4, myMath.sum(new int[] {4}));
		}
	}
------------------------------------------------------------------------------
40 - Step 4: Other assert methods
	Created AssertTest:

------------------------------------------------------------------------------
41 - Step 5: Important Annotations
	@Before and @After.
	The order of the tests is not guaranteed. But @Before will run before EVERY @Test. You can use it for example to connect to a database.
	
	@BeforeClass and @AfterClass
		Before and After the class is loaded. Methods must be static.


------------------------------------------------------------------------------
SECTION 6 - BASIC TOOLS AND FRAMEWORKS - MOCKITO IN 5 STEPS
------------------------------------------------------------------------------
42 - Section Introduction - Mockito in 5 Steps
	Code in: https://github.com/in28minutes/spring-master-class/tree/master/00-framework-tool-introductions/04.Mockito-Introduction-In-5-Steps

------------------------------------------------------------------------------
43 - Step 1: Setting an example using http://start.spring.io
	Generate a Maven Project with JAva and Spring Boot 2.1.1
		Group: com.fabiano.mockito
		Artifact: mockito-in-5-steps
		
	Create SomeBusinessImpl.java and interface DataService.
	Now we want to be able to create a unit test: we're going to write a stub.
	
	//SomeBusinessImpl is dependent on DataService.
	public class SomeBusinessImpl {
		private DataService dataService;
		
		public SomeBusinessImpl(DataService dataService) {
			super();
			this.dataService = dataService;
		}

		int findTheGreatestFromAllData() {
			int[] data = dataService.retrieveAllData();
			int greatest = Integer.MIN_VALUE;
			for (int value : data) {
				if (value > greatest) {
					greatest = value;
				}
			}
			return greatest;
		}
	}
	
	-------
	package com.fabiano.mockito.mockitoin5steps;

	public interface DataService {
		int[] retrieveAllData();
	}


------------------------------------------------------------------------------
44 - Step 2: Using a Stubs - Disadvantages
	Create new JUnit 4 test case. 
	Class under Test, select SomeBusinessImpl. 
	Class name: SomeBusinessTest
	Finish.
	
	Then create a test method:
	
	public class SomeBusinessStubTest {

		@Test
		public void testFindTheGreatestAllData() {
			SomeBusinessImpl businessImpl = new SomeBusinessImpl(new DataServiceStub());
			int result = businessImpl.findTheGreatestFromAllData();
			assertEquals(24, result);
		}

	}

	class DataServiceStub implements DataService {
		@Override
		public int[] retrieveAllData() {
			return new int [] {24, 6, 15};
		}
		
	}

	It works fine. But the drawback is that we're using a stub. What's the problem with it?
	1. Have to write lots of code to maintain that. 
		class DataServiceStub implements DataService {
			@Override
			public int[] retrieveAllData() {
				return new int [] {24, 6, 15};
			}
		}
	
	2. If you want to create different scenarios (like new int[] {} empty), you have to create multiple stub versions.
	
	That's when mocks come in. They make very easy to dynamically create different classes and make them return data that we would want to return.
	

------------------------------------------------------------------------------
45 - Step 3: Your first mock with Mockito
	Now let's replace the Stub and create another test class: SomeBusinessMockTest.
	
	import org.junit.Test;
	import static org.mockito.Mockito.mock;
	import static org.mockito.Mockito.when;

	public class SomeBusinessMockTest {

		@Test
		public void testFindTheGreatestAllData() {
			DataService dataServiceMock = mock(DataService.class);
			
			//what we want
			//dataServiceMock.retrieveAllData() => new int[] {24, 15, 3}
			// so, when this method we called, then return new int[] {24, 15, 3}
			when(dataServiceMock.retrieveAllData()).thenReturn(new int[] {24, 15, 3});
			
			SomeBusinessImpl businessImpl = new SomeBusinessImpl(dataServiceMock);
			int result = businessImpl.findTheGreatestFromAllData();
			assertEquals(24, result);
		}
	}
	
	The great thing about mocking is that it's so simple. And we can repeat data, like this other method:
	
	@Test
	public void testFindTheGreatestAllData_ForOneValue() {
		DataService dataServiceMock = mock(DataService.class);
		when(dataServiceMock.retrieveAllData()).thenReturn(new int[] {15});
		SomeBusinessImpl businessImpl = new SomeBusinessImpl(dataServiceMock);
		int result = businessImpl.findTheGreatestFromAllData();
		assertEquals(15, result);
	}
	
	You can create mock for classes as well. When using mocks, there are things that you need to be careful about:
	1. How do you send the mock out to the class you want to test. (like in : SomeBusinessImpl(DataService dataService), constructor injection). 
	So we're passing mock by constructor. Conceptually this is very similar to Spring.

------------------------------------------------------------------------------
46 - Step 4: Using Mockito Annotations - @Mock, @InjectMocks, @RunWith
	
	//When using Mockito annotations, then we would need to use a runWith
	@RunWith(MockitoJUnitRunner.class)
	public class SomeBusinessMockAnnotationTest {

		@Mock
		DataService dataServiceMock;
		
		@InjectMocks
		SomeBusinessImpl businessImpl;
		
		@Test
		public void testFindTheGreatestFromAllData() {
			when(dataServiceMock.retrieveAllData()).thenReturn(new int[] {24, 15, 3});
			assertEquals(24, businessImpl.findTheGreatestFromAllData());
		}

		@Test
		public void testFindTheGreatestFromAllData_ForOneValue() {
			when(dataServiceMock.retrieveAllData()).thenReturn(new int[] {15});
			assertEquals(15, businessImpl.findTheGreatestFromAllData());
		}
		
		@Test
		public void testFindTheGreatestFromAllData_NoValues() {
			when(dataServiceMock.retrieveAllData()).thenReturn(new int[] {});
			assertEquals(Integer.MIN_VALUE, businessImpl.findTheGreatestFromAllData());
		}
	}	

------------------------------------------------------------------------------
42 - Step 5: Mocking List Interface

	public class ListTest {
		@Test
		public void testSize() {
			List listMock = mock(List.class);
			//how to mock list size?
			when(listMock.size()).thenReturn(10);
			assertEquals(10, listMock.size());
			//return the same 10, because there's a single return
			assertEquals(10, listMock.size());
		}
		
		@Test
		public void testSize_multipleReturns() {
			List listMock = mock(List.class);
			//how to mock list size for multiple asserts?
			when(listMock.size()).thenReturn(10).thenReturn(20);
			assertEquals(10, listMock.size());
			assertEquals(20, listMock.size());
			//return the last value (20)
			assertEquals(20, listMock.size());
		}
		
		@Test
		public void testGet_SpecificParameter() {
			List listMock = mock(List.class);
			when(listMock.get(0)).thenReturn("SomeString");
			assertEquals("SomeString", listMock.get(0));
			assertEquals(null, listMock.get(1));
		}
		
		@Test
		public void testGet_GenericParameter() {
			List listMock = mock(List.class);
			when(listMock.get(Mockito.anyInt())).thenReturn("SomeString");
			assertEquals("SomeString", listMock.get(0));
			assertEquals("SomeString", listMock.get(1));
		}
	}

------------------------------------------------------------------------------
SECTION 7 - SPRING LEVEL 3 - UNIT TESTING WITH SPRING FRAMEWORK
------------------------------------------------------------------------------
48 - Section Introduction - Unit testing with Spring Framework
	Code in: https://github.com/in28minutes/spring-master-class/tree/master/01-spring-in-depth 
	Steps 27, 28 and 29
	
------------------------------------------------------------------------------
49 - Step 27: Spring Unit Testing with a Java Context
	Change 
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-test</artifactId>
			<scope>test</scope>
		</dependency>
		
		TO 
		
		<dependency>
			<groupId>org.springframework</groupId>
			<artifactId>spring-test</artifactId>
			<scope>test</scope>
		</dependency>
		<dependency>
			<groupId>junit</groupId>
			<artifactId>junit</artifactId>
			<scope>test</scope>
		</dependency>
		<dependency>
			<groupId>org.mockito</groupId>
			<artifactId>mockito-core</artifactId>
			<scope>test</scope>
		</dependency>
		
		comment @SpringBootTest in SpringIn5StepsBasicApplicationTests
		
		
	Write a test for BinarySearchImpl: new JUnit Test Case com.fabiano.spring.basics.springin5steps.basic.BinarySearchTest.java
	
	//Load the context
	@RunWith(SpringRunner.class)
	@ContextConfiguration(classes=SpringIn5StepsBasicApplication.class)
	public class BinarySearchTest {
		
		//Get this bean from the context
		@Autowired
		BinarySearchImpl binarySearch;

		@Test
		public void testBasicScenario() {
			//Call method on binarySearch
			int actualResult = binarySearch.binarySearch(new int[] {}, 5);
			//Check if the value is correct
			assertEquals(3, actualResult);
		}

	}

------------------------------------------------------------------------------
50 - Step 28: Spring Unit Testing with an XML Context
	BinarySearchXMLConfigurationTest.java
	
	The difference is this:
		@ContextConfiguration(locations="/applicationContext.xml")
		public class BinarySearchXMLConfigurationTest {
			...
		}
	
	You can also create a testContext.xml based on applicationContext.xml and add it to src/test/resources:
		<?xml version="1.0" encoding="UTF-8"?>
		<beans xmlns="http://www.springframework.org/schema/beans"
			xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
			xmlns:context="http://www.springframework.org/schema/context"
			xsi:schemaLocation="http://www.springframework.org/schema/beans
							   http://www.springframework.org/schema/beans/spring-beans-3.0.xsd
							   http://www.springframework.org/schema/context
							   http://www.springframework.org/schema/context/spring-context-3.0.xsd">
			<import resource="classpath:applicationContext.xml"/>
		</beans>
		
	//@ContextConfiguration(locations="/applicationContext.xml")
	@ContextConfiguration(locations="/testContext.xml") //specific for testing is also an option
	public class BinarySearchXMLConfigurationTest {
		...
	}
	
------------------------------------------------------------------------------
51 - Step 29: Spring Unit Testing with Mockito
	Created method getData in SomeCdiDao
	public int[] getData() {
		return new int[] {5, 89, 100};
	}
	
	Created method findGreatest in SomeCdiBusiness:
	public int findGreatest() {
		int greatest = Integer.MIN_VALUE;
		int[] data = someCdiDao.getData();
		for (int value : data) {
			if (value > greatest)
				greatest = value;
		}
		return greatest;
	}
	
	Then create SomeCdiBusinessTest:
	
	@RunWith(SpringRunner.class)
	@ContextConfiguration(classes=SpringIn5StepsBasicApplication.class)
	public class SomeCdiBusinessTest {
		
		//Get this bean from the context
		@Autowired
		SomeCdiBusiness business;
	 
		@Test
		public void testBasicScenario() {
			//Call method on binarySearch
			int actualResult = business.findGreatest();
			//Check if the value is correct
			assertEquals(100, actualResult);
		}

	}
	
	This is bad because we're depending on the Data Layer (what if data layer is down, someone changes the value etc). 
	That's where Mockito enters. Let's change:
	
	@RunWith(MockitoJUnitRunner.class)
	public class SomeCdiBusinessTest {
		
		//Inject Mock
		@InjectMocks
		SomeCdiBusiness business;
		
		//Create Mock
		@Mock
		SomeCdiDao daoMock;
	 
		@Test
		public void testBasicScenario() {
			
			//when daoMock.getData method is called return int[]{2,4};
			Mockito.when(daoMock.getData()).thenReturn(new int[] {2,4});
			
			//Call method on binarySearch
			int actualResult = business.findGreatest();
			
			//Check if the value is correct
			assertEquals(4, actualResult);
		}
		
		@Test
		public void testBasicScenario2() {
			Mockito.when(daoMock.getData()).thenReturn(new int[] {});
			int actualResult = business.findGreatest();
			assertEquals(Integer.MIN_VALUE, actualResult);
		}
		
		@Test
		public void testBasicScenario3() {
			Mockito.when(daoMock.getData()).thenReturn(new int[] {2,2});
			int actualResult = business.findGreatest();
			assertEquals(2, actualResult);
		}

	}
	
------------------------------------------------------------------------------
SECTION 8 - SPRING LEVEL 4 - Spring Boot in 10 Steps
------------------------------------------------------------------------------
52 - Introduction Section - Spring Boot in 10 Steps
	Understand how things were done before Spring Boot. All the code can be found at: 
	https://github.com/in28minutes/spring-master-class/tree/master/00-framework-tool-introductions/05.Spring-Boot-Introduction-In-10-Steps

------------------------------------------------------------------------------
53 - Step 1: Introduction to Spring Boot - Goals and Important Features
	Building 25, 50 micro services instead of 1 big monolithic applications. It has quickly become the number one framework to develop 
	micro services in the Java world.
	
	Goals: 
		Enable building production ready applications quickly
		Provide common non-functional features
		- embedded servers
		- metrics
		- health checks
		- externalized configuration
	
	What Spring Boot is NOT!
		ZERO code generation
		Neither an application server nor a web server
		
	Features
		Quick Starter Projects with Auto Configuration 
		
		- WEB
			For example, developing a web application, would need: Spring MVC, Spring Core, some validation framework, logging framework, 
			in addition to that, I would need to configure all this stuff that is needed. Spring MVC: dispatcher Servlet, view resolvers.
			However, with Spring Boot Starter Project, just add spring boot starter project and you'll get spring MVC, spring core, validation and also logging for free.
				
		- JPA
			Similarly for JPA, spring starter called Spring Boot Starter JPA, once you use this starter, you would not only get JPA but also a default implementation of
			JPA with hibernate and also auto configuration of that. You'd not worry about the framework part and you can directly start creating your entities. 
		
		- Embedded Servers - Tomcat, Jetty or Undertow
			You can package your server, like Tomcat along with your application jar. So I can include the Tomcat server in my application jar. I don't need anything else but Java 
			to run my jar in, say, a Linux box. This makes a huge difference in the micro services world. 
		
		Production-ready features
			- Metrics, health checks 
				It provides monitoring for your application through something called Spring Boot actuator. For example, you can find out how many times a particular service is called, failed
				and check whether your application is up and running or not. All these features come BUILT IN. 
		
			- Externalized configuration
				you can simply create property files matching a simple naming convention and that's it. Spring Boot also provides support for different profiles. 
		
-----------------------------------------------------------------------------
54 - Step 2: Developing Spring Applications before Spring Boot
	We'll look at one of the projects which we developed in our Spring MVC course. Before we start with any project, we need to decide what frameworks and dependencies
	to use.  This was a web project, so we would want to use Spring MVC and things like that. So we needed to make decisions on what frameworks and what versions of them to use.
	
	<depencency>
		<groupId>org.springframework</groupId>
		<artifactId>spring-webmvc</artifactId>
		<version>4.2.2-RELEASE</version>
	</dependency>
	<depencency>
		<groupId>org.springframework.security</groupId>
		<artifactId>spring-security-web</artifactId>
		<version>4.0.1-RELEASE</version>
	</dependency>
	<depencency>
		<groupId>org.springframework.security</groupId>
		<artifactId>spring-security-config</artifactId>
		<version>4.0.1-RELEASE</version>
	</dependency>
	<depencency>
		<groupId>com.fasterxml.jackson.core</groupId>
		<artifactId>jackson-databind</artifactId>
		<version>2.5.3</version>
	</dependency>
	
	I would want to use jackson databind because I want to do some binding and validation. I'd would want to use JSTL and Hibernate validator and also 
	for logging log4j.
	
	Sometimes, the versions are not compatible. Deciding the frameworks, which version to use is a major decision that we needed to make when we were
	not using Spring Boot. We needed to implement Default Exception Handling and a complete Spring Configuration file. 
	
	All of this would be replaced by Spring Boot starter web in combination with Spring Boot starter security.
	
------------------------------------------------------------------------------
55 - Step 3: Using Spring Initializr to create a Spring Boot Application
	In this step we'll create a simple Spring Boot project and look at all the magic a simple starter project can provide.
	Go to start.spring.io > Maven Project | Java | Spring Boot 2.0.0 | com.fabiano.springboot.basics | springboot-in-10-steps
	
	We'd want to develop simple REST service and to be able to do that, we need "Web" Starter
	
	Generate Project, import to eclipse as maven project and the dependencies will start to download.

------------------------------------------------------------------------------
56 - Step 4: Creating a Simple REST Controller
	Let's create a service http://localhost:8080/books => few hardcoded books.
	
	Let's create a simple Bean named Book. 
		package com.fabiano.springboot.basics.springbootin10steps;
		public class Book {
			long id;
			String name;
			String author;
			
			public Book(long id, String name, String author) {
				super();
				this.id = id;
				this.name = name;
				this.author = author;
			}
			public long getId() {
				return id;
			}
			public void setId(long id) {
				this.id = id;
			}
			public String getName() {
				return name;
			}
			public void setName(String name) {
				this.name = name;
			}
			public String getAuthor() {
				return author;
			}
			public void setAuthor(String author) {
				this.author = author;
			}
			
			@Override
			public String toString() {
				return "Book [id=" + id + ", name=" + name + ", author=" + author + "]";
			}
		}

	Then BooksController:
	
	package com.fabiano.springboot.basics.springbootin10steps;

	import java.util.Arrays;
	import java.util.List;

	import org.springframework.web.bind.annotation.GetMapping;
	import org.springframework.web.bind.annotation.RestController;

	@RestController
	public class BooksController {
		
		@GetMapping("/books")
		public List<Book> getAllBooks(){
			return Arrays.asList(
				new Book(1l, "Mastering Spring 5.0", "Ranga Karanam"));
		}
	}

	Start the server: Run SpringbootIn10StepsApplication.java and go to http://localhost:8080/books:
	[{"id":1,"name":"Mastering Spring 5.0","author":"Ranga Karanam"}]
------------------------------------------------------------------------------
57 - Step 5: What is Spring Boot Auto Configuration?

------------------------------------------------------------------------------
58 - Step 6: Spring Boot vs Spring vs Spring MVC

------------------------------------------------------------------------------
59 - Step 7: Spring Boot Starter Projects - Starter Web and Starter JPA

------------------------------------------------------------------------------
60 - Step 8: Overview of different Spring Boot Starter Projects

------------------------------------------------------------------------------
61 - Step 9: Spring Boot Actuator

------------------------------------------------------------------------------
62 - Step 9: Spring Boot Developer Tools


------------------------------------------------------------------------------
SECTION 9 - SPRING LEVEL 5 - SPRING AOP
------------------------------------------------------------------------------
63 - Section Introduction - Spring AOP

------------------------------------------------------------------------------
64 - Spring JDBC to JPA with Hibernate - Github Folder

------------------------------------------------------------------------------
65 - Spring AOP Github Folder

------------------------------------------------------------------------------
66 - Step 01 - Setting up AOP Example - Part 1

------------------------------------------------------------------------------
67 - Step 02 - Setting up AOP Example - Part 2

------------------------------------------------------------------------------
68 - Step 03 - Defining an @Before advice

------------------------------------------------------------------------------
69 - Step 04 - Understand AOP Terminology - Pointcut, Advice, Aspect and Join Point

------------------------------------------------------------------------------
70 - Step 05 - Using @After, @AfterReturning, @AfterThrowing Advices

------------------------------------------------------------------------------
71 - Step 06 - Using @Around advice to implement performance tracing

------------------------------------------------------------------------------
72 - Step 07 - Best Practice: Use common Pointcut Configuration

------------------------------------------------------------------------------
73 - Step 08 - Quick summary of other Pointcuts

------------------------------------------------------------------------------
74 - Step 09 - Creating custom Annotation and an Aspect for Tracking Time

------------------------------------------------------------------------------
SECTION 10 - SPRING LEVEL 6 - INTERACTING WITH DATABASES - SPRING JPA, JDBC AND SPRING DATA
------------------------------------------------------------------------------
75 - Section Introduction - Spring JDBC, JPA and Spring Data

------------------------------------------------------------------------------
76 - Step 01 - Setting up a project with JDBC, JPA, H2 and Web Dependencies

------------------------------------------------------------------------------
77 - Step 02 - Launching up H2 Console

------------------------------------------------------------------------------
78 - Step 03 - Creating a Database Table in H2 

------------------------------------------------------------------------------
79 - Step 04 - Populate data into Person Table

------------------------------------------------------------------------------
80 - Step 05 - Implement findAll persons Spring JDBC Query Method

------------------------------------------------------------------------------
81 - Step 06 - Execute the findAll method using CommandLineRunner

------------------------------------------------------------------------------
82 - Step 07 - A Quick Review - JDBC vs Spring JDBC

------------------------------------------------------------------------------
83 - Step 08 - Whats in the background? Understanding Spring Boot Autoconfiguration

------------------------------------------------------------------------------
84 - Step 09 - Implementing findById Spring JDBC Query Method

------------------------------------------------------------------------------
85 - Step 10 - Implementing deleteById Spring JDBC Update Method

------------------------------------------------------------------------------
86 - Step 11 - Implementing insert and update Spring JDBC Update Methods

------------------------------------------------------------------------------
87 - Step 12 - Creating a custom Spring JDBC RowMapper

------------------------------------------------------------------------------
88 - Step 13 - Quick Introduction to JPA

------------------------------------------------------------------------------
89 - Step 14 - Defining Person Entity

------------------------------------------------------------------------------
90 - Step 15 - Implementing findById JPA Repository Method

------------------------------------------------------------------------------
91 - Step 16 - Implementing insert and update JPA Repository Methods

------------------------------------------------------------------------------
92 - Step 17 - Implementing deleteById JPA Repository Method

-----------------------------------------------------------------------------
93 - Step 18 - Implementing findAll using JPQL Named Query

------------------------------------------------------------------------------
94 - Step 19 - Introduction to Spring Data JPA

------------------------------------------------------------------------------
95 - Step 20 - Connecting to Other Databases


------------------------------------------------------------------------------
SECTION 11 - QUICK PREVIEW - WEB APPLICATIONS WITH SPRING MVC
------------------------------------------------------------------------------
96 - Section Introduction - Basic Web Application

------------------------------------------------------------------------------
97 - Step 01: Setting up your first Java Web Application

------------------------------------------------------------------------------
98 - Step 01: Theory 1 - Maven and Magic

------------------------------------------------------------------------------
99 - Step 01: Theory 2 - What is a Servlet?

------------------------------------------------------------------------------
100 - Step 01: Theory 3 - Web Application Request Flow

------------------------------------------------------------------------------
101 - Step 01: Theory 4 - Understand Your First Servlet - LoginServlet

------------------------------------------------------------------------------
102. Step 02 : Create LoginServlet From Scratch Again and Your First View

------------------------------------------------------------------------------
103. Step 02 : Theory - Play Time - Let's Try Breaking Things

------------------------------------------------------------------------------
104. Step 03 : Passing Request Parameters using Get Method

------------------------------------------------------------------------------
105. Step 03 : Theory - Introduction and End to Scriptlets

------------------------------------------------------------------------------
106. Step 04 : Disadvantages of Get Parameters

------------------------------------------------------------------------------
107. Step 05 : Your First Post Request

------------------------------------------------------------------------------
108. Step 06 : Your First Servlet doPost Method

------------------------------------------------------------------------------
109. Step 07 : Lets Add a Password Field

------------------------------------------------------------------------------
110. Step 10 : Setting up Maven,Tomcat and Simple JEE Application

------------------------------------------------------------------------------
111. Step 11 : Setting up Spring MVC with 4 mini steps

------------------------------------------------------------------------------
112. Step 12 : Your First Spring MVC Controller

------------------------------------------------------------------------------
113. Step 13 : Part 1 - Your First Spring MVC View : ViewResolver

------------------------------------------------------------------------------
114. Step 13 : Part 2 - Theory Break - Spring MVC Architecture

------------------------------------------------------------------------------
115. Step 13 : Part 3 - Play Break - Try Breaking Things

------------------------------------------------------------------------------
116. Step 14 : Add Logging Framework Log4j

------------------------------------------------------------------------------
117. Step 15 : Redirect to Welcome Page : ModelMap and @RequestParam

------------------------------------------------------------------------------
118. Step 16 : Use LoginService to Authenticate

------------------------------------------------------------------------------
119. Step 17 : Spring Autowiring and Dependency Injection

------------------------------------------------------------------------------
SECTION: 12 - BASIC TOOLS AND FRAMEWORKS - ECLIPSE IN 5 STEPS
------------------------------------------------------------------------------
120. Section Introduction - Eclipse in 5 Steps

------------------------------------------------------------------------------
121. Step 1 : Create a Java Project

------------------------------------------------------------------------------
122. Step 2 : Keyboard Shortcuts

------------------------------------------------------------------------------
123. Step 3 : Views and Perspectives

------------------------------------------------------------------------------
124. Step 4 : Save Actions

------------------------------------------------------------------------------
125. Step 5 : Code Generation

------------------------------------------------------------------------------
SECTION: 13 - BASIC TOOLS AND FRAMEWORKS - MAVEN IN 5 STEPS
------------------------------------------------------------------------------
126. Section Introduction - Maven in 5 Steps

------------------------------------------------------------------------------
127. Step 1 : Creating and importing a Maven Project

------------------------------------------------------------------------------
128. Step 2 : Understanding Project Object Model - pom.xml

------------------------------------------------------------------------------
129. Step 3 : Maven Build Life Cycle

------------------------------------------------------------------------------
130. Step 4 : How does Maven Work?

------------------------------------------------------------------------------
131. Step 5 : Important Maven Commands

------------------------------------------------------------------------------
SECTION: 14 - CONGRATUATIONS
------------------------------------------------------------------------------
132. Our Best Courses : Bonus Lecture

------------------------------------------------------------------------------
133. Spring Master Class - Congratulations on Completing the Course




























