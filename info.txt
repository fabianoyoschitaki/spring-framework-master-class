What are the beans?
What are the dependencies of a bean?
Where to search for beans? => No need as SpringBootApplication scans package and subs

@Component (beans)
@Autowired (dependency)
@Primary (disambiguous component)

Older versions of Spring:
Setter Injection -> if dependency is optional
Constructor Injection -> if dependency is mandatory

You don't need a setter with the @Autowired, the value is set by reflection.
You can also autowire by name

@Autowired
@Primary
private SortAlgorithm sortAlgorithm;

@Autowired
private SortAlgorithm bubleSortAlgorithm;

@Primary has priority over the bean name.
------------------------------------------------------------------------------
13 - Autowiring in depth - @Qualifier annotation
	Another way is put
	@Qualifier both in the dependency class and the class which has the dependency. @Qualifier has priority over @Primary!
	use @Primary if you have a more efficient algorithm among all. In case you have to switch to the other one, you can use autowiring by name or @Qualifier.
------------------------------------------------------------------------------
14 - Scope of a bean - Prototype and Singleton
	Bean Scope (default singleton)
	- singleton: One instance per Spring Context
	- prototype: New bean whenever requested
	- request: One bean per HTTP request
	- session: One bean per HTTP session
------------------------------------------------------------------------------
23 - Complex Scope Scenarios of a Spring Bean - Mix Prototype and Singleton
	if PersonDAO is singleton and has JdbcConnection is prototype as dependency, the same jdbcConnection object will be returned. 
	So you have to create a proxy
	@Scope(value=ConfigurableBeanFactory.SCOPE_PROTOTYPE, proxyMode=ScopedProxyMode.TARGET_CLASS)
------------------------------------------------------------------------------
24 - Difference between Spring Singleton and GOF Singleton
	GOF - 1 instance per JVM, even if multiple applications are running in the same JVM, the same instance would be returned. 
	Spring - 1 instance per application context. If there are 5 application contexts in the same JVM, 5 different instances.
------------------------------------------------------------------------------	
25 - Using Component Scan to scan for beans
	if you application is com.test, every sub package will be scanned for components.
	But if you have components say in com.abc, you have to add in the spring application:
	@ComponentScan("com.abc")
------------------------------------------------------------------------------	
26 - Lifecycle of a Bean @PostConstruct and @PreDestroy (callback methods)
	when put @Component, the lifecycle of a bean is going to be managed by the spring IOC container.
	if you want to do certain things before being destroyed or after it was created;
	One of the first things that the IOC container does is autowire the dependencies. Then, call 
	@PostConstruct method after that. The @PreDestroy is similar, but it happens when the instance
	is in the process of being removed by the container. 
------------------------------------------------------------------------------
27 - Container and Dependency Injection (CDI)
	Java EE Dependency Injection Standard (JSR 330)
	Spring supports most annotations:
		@Inject (@Autowired)
		@Named (@Component & @Qualifier)
		@Singleton (defined a scope of Singleton)
	Similar to JPA and Hibernate, interface and implementation, CDI defines how to do dependency injection. 
	In order to use CDI, add to pom.xml, below spring-boot-starter:
	<dependency>
		<groupId>javax.inject</groupId>
		<artifactId>javax.inject</artifactId>
		<version>1</version>
	</dependency>
	
	When use CDI annotations or Spring annotations? CDI is a Java EE standard. You'd always stick to a standard, 
	like JPA instead of Hibernate. There's actually no good reasons why use one over each other... :P 
	Btw CDI offers really good flexibility tomorrow if you want to switch away from Spring as Dependency Injection Framework.
------------------------------------------------------------------------------	
28 - Ignore SLF4J Errors in Step 19 - We will fix them in Step 20 
	As we start removing Spring Boot and bringing in Spring core in the next step, you would see
	
	A few SLF4J errors.
	Logging does not work
	Do not worry about them. We will fix them in Step 20.
------------------------------------------------------------------------------	
29 - Removing Spring Boot in Basic Application
	How to use Spring without Spring Boot? Let's remove spring boot starter.  
	Change in pom.xml:
	<dependency>
		<groupId>org.springframework.boot</groupId>
		<artifactId>spring-boot-starter</artifactId>
	</dependency>
	to
	<dependency>
		<groupId>org.springframework</groupId>
		<artifactId>spring-core</artifactId>
	</dependency>

	<dependency>
		<groupId>org.springframework</groupId>
		<artifactId>spring-context</artifactId>
	</dependency>
	if you run SpringIn5StepsBasicApplication, you'll get an error because spring boot is not available when running.
	The reason why there are no compile errors is because:
	<dependency>
		<groupId>org.springframework.boot</groupId>
		<artifactId>spring-boot-starter-test</artifactId>
		<scope>test</scope>
	</dependency>
	which we will remove later.
	
	The first thing to get rid of this error is to initialize Application Context: 
		Change @SpringBootApplication to @Configuration (org.springframework.context.annotation.Configuration)
	
	Also, SpringApplication is from spring boot. 
		Change ApplicationContext applicationContext = SpringApplication.run(SpringIn5StepsBasicApplication.class, args);
		to ApplicationContext applicationContext = new AnnotationConfigApplicationContext(SpringIn5StepsBasicApplication.class);
		
	The other change is that we have to scan the package (which spring boot does by default)
		@ComponentScan("") or declare the package explicitly.
	
	We will get Caused by: java.lang.ClassNotFoundException: org.slf4j.LoggerFactory, so we add in pom.xml:
		<dependency>
			<groupId>org.slf4j</groupId>
			<artifactId>slf4j-api</artifactId>
		</dependency>
------------------------------------------------------------------------------
30 - Fixing minor stuff - Add Logback and Close Application Context
	We have to close the application context:
		from ApplicationContext applicationContext = new AnnotationConfigApplicationContext(SpringIn5StepsBasicApplication.class);
		to ApplicationContext applicationContext = new AnnotationConfigApplicationContext(SpringIn5StepsBasicApplication.class);
		
		applicationContext.close();
		
	Another way would be using Java 7 feature:
		try (AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext(
				SpringIn5StepsBasicApplication.class)) {
				
	The log wasn't working properly. This is because we added the slf4j-api but not the implementation. Let's use logback which Spring uses by default:
		SLF4J: Failed to load class "org.slf4j.impl.StaticLoggerBinder".
		SLF4J: Defaulting to no-operation (NOP) logger implementation
		SLF4J: See http://www.slf4j.org/codes.html#StaticLoggerBinder for further details.
	
	The implementation:
		<!-- SLF4J implementation -->
		<dependency>
			<groupId>ch.qos.logback</groupId>
			<artifactId>logback-classic</artifactId>
		</dependency>
------------------------------------------------------------------------------
31 - Defining Spring Application Context Using XML - Part 1
	Duplicate com.fabiano.spring.basics.springin5steps.scope classes to com.fabiano.spring.basics.springin5steps.xml
		- XMLJdbcConnection and XMLPersonDAO
		- remove annotations @Component and @Scope(ConfigurableBeanFactory.SCOPE_SINGLETON)
	
	Before Spring 2.5, all these things had to be wired manually through XML:
		- Create new xml file applicationContext.xml in src/main/resources. Copy content from https://docs.spring.io/spring/docs/3.0.x/spring-framework-reference/html/beans.html:
			<?xml version="1.0" encoding="UTF-8"?>
			<beans xmlns="http://www.springframework.org/schema/beans"
				   xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
				   xsi:schemaLocation="http://www.springframework.org/schema/beans
					   http://www.springframework.org/schema/beans/spring-beans-3.0.xsd">

			  <bean id="..." class="...">
				<!-- collaborators and configuration for this bean go here -->
			  </bean>

			  <bean id="..." class="...">
				<!-- collaborators and configuration for this bean go here -->
			  </bean>

			  <!-- more bean definitions go here -->

			</beans>
		
		- Create the beans
			<bean id="xmlJdbcConnection" 
				class="com.fabiano.spring.basics.springin5steps.xml.XmlJdbcConnection">
			</bean>

			<bean id="xmlPersonDAO" 
				class="com.fabiano.spring.basics.springin5steps.xml.XmlPersonDAO">
			</bean>
			
		- Wire the beans 
			<bean id="xmlPersonDAO" 
				class="com.fabiano.spring.basics.springin5steps.xml.XmlPersonDAO">
				<property name="xmlJdbcConnection" ref="xmlJdbcConnection"/>
			</bean>
------------------------------------------------------------------------------
32 - Defining Spring Application Context Using XML - Part 2
	Created SpringIn5StepsXMLContextApplication.java
	Now, to load the beans using applicationContextXML:
		try (ClassPathXmlApplicationContext applicationContext = 
			new ClassPathXmlApplicationContext("applicationContext.xml")) {
			XmlPersonDAO personDao = applicationContext.getBean(XmlPersonDAO.class);
			System.out.println(personDao);
			System.out.println(personDao.getXmlJdbcConnection());
		}
		
	Before annotations, it was really difficult to wire beans using Spring. 
------------------------------------------------------------------------------
33 - Mixing XML Context with Component Scan for Beans defined with Annotations
	In SpringIn5StepsXMLContextApplication.java, there is no need to use @Component and @Configuration, because it is based on XML. 
	Let's check which beans are being loaded:
		LOGGER.info("Beans Loaded -> {}", (Object)applicationContext.getBeanDefinitionNames());
		Beans Loaded -> [xmlJdbcConnection, xmlPersonDAO]
		
	These 2 beans are the ones which we have defined in the applicationContext.xml.
	What if we want to load other beans? (basic, cdi and scope packages)
	A: Component Scan in applicationContext.xml:
	
		<beans xmlns="http://www.springframework.org/schema/beans"
			xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
			xmlns:context="http://www.springframework.org/schema/context"
			xsi:schemaLocation="http://www.springframework.org/schema/beans
							   http://www.springframework.org/schema/beans/spring-beans-3.0.xsd
							   http://www.springframework.org/schema/context
							   http://www.springframework.org/schema/context/spring-context-3.0.xsd">

			<context:component-scan base-package="com.fabiano.spring.basics"></context:component-scan>
		Beans Loaded -> [componentDAO, scopedTarget.componentJdbcConnection, componentJdbcConnection, 
						 binarySearchImpl, bubbleSortAlgorithm, quickSortAlgorithm, someCdiBusiness, someCdiDao, 
						 scopedTarget.jdbcConnection, jdbcConnection, personDAO, springIn5StepsBasicApplication, 
						 springIn5StepsCdiApplication, springIn5StepsComponentScanApplication, springIn5StepsScopeApplication, 
						 org.springframework.context.annotation.internalConfigurationAnnotationProcessor, 
						 org.springframework.context.annotation.internalAutowiredAnnotationProcessor, 
						 org.springframework.context.annotation.internalRequiredAnnotationProcessor, 
						 org.springframework.context.annotation.internalCommonAnnotationProcessor, 
						 org.springframework.context.event.internalEventListenerProcessor, 
						 org.springframework.context.event.internalEventListenerFactory, 
						 xmlJdbcConnection, xmlPersonDAO]
	
	So here we are using a combination of defining beans and component scan. To remove both beans in applicationContext.xml, 
	add to XmlPersonDAO.java: @Component to class and @AutoWired to XmlJdbcConnection attribute
	add to XmlJdbcConnection.java: @Component to class

------------------------------------------------------------------------------
34 - IOC Container vs Application Context vs Bean Factory
	DISAMBIGUATION:
		- IOC Container: Let's say WelcomeController needs WelcomeService. WC directly creates an instance of WS 
			@RestController
			public class WelcomeController {
				private WelcomeService service = new WelcomeService(); 
			
			But when using Spring, then we would do this:
				@RestController
				public class WelcomeController {
					@AutoWired
					private WelcomeService service; 
					
				@Component
				public class WelcomeService
			
			Who does that? Spring Framework. It shifts the responsibility of creating the bean out to spring. 
			The control moves out of the controller or the component which needs the dependency to the framework which is injecting the dependency in. 
			The program that provides inversion of control is the IOC container. Manage, create, autowire beans. 
			In Spring, there are two implementations of the IOC Container: Application Context and Bean Factory. In all scenarios we've been using
			Application Context because Spring recommend to use it in 99% of the scenarios, except when memory is a premmium (like an IOT device)
			
			What is the difference between Application Context and Bean Factory? AC is nothing but Bean Factory ++
			INCOMPLETO... 3:10
				
		
		- Application Context (second one of the two implementations of the IOC container)
			It is BeanFactory++: Spring's AOP features, internationalization, WebApplicationContext for web applications etc

		- Bean Factory (first one of the two implementations of the IOC container)
			It only provides the basic management for the beans and wiring of dependencies, nothing more.
------------------------------------------------------------------------------
35 - @Component vs @Service vs @Repository vs @Controller
	These are the different stereotypes that are present in Spring.	Talking about web applications:

		Web Layer/UI Layer - shows information to the user
		Business Layer - responsible for the business logic 
		Data Layer - responsible for getting the data from the database or an external interface		

	@Component: Generic Component. If you're not sure if something belongs to one of those layers, then you can use @Component.
	
	The other 3 annotations are very specific:
		@Repository: Encapsulating storage, retrieval, and search behavior typically from a relational database. (Data Layer)
		@Service: Business Service Facade. (Business Layer)
		@Controller: Controller in MVC Pattern. (Web Layer)
	
	So let's change PersonDAO and ComponentDAO to @Repsitory 
	and BinarySearchImpl, BubbleSortAlgorithm, QuickSortAlgorithm and SortAlgorithm to @Service (Business!)

	This does not change the functionality. So why should I use a specific annotation. In the AOP section, you'll see you can add
	different functionalities by putting them in different categories and apply different logic for each of these categories. 
	For example, Spring provides a default exception translation facility if you use Repository. There are lots of JDBC Exceptions, so if you put this @Repository, Spring translates them, if you put @Component you will not be able to use that feature. 
	Also, let's suppose you want to log everything that is in your Business Layer. In that kind of scenario, you would have to identity everything that has an @Service annotation and use AOP and log everything. (We'll talk about that in the AOP section) 
------------------------------------------------------------------------------
36 - Read values from external properties file
	Typically applications have a lot of configuration. For example, in the data layer, you might be talking to a database. So this configuration might be different in different environments. Also, the external services that you talk to might be different in different environments. 
	So these kind of values are good to be externalized into property file. 
	
	1. Let's create com.fabiano.spring.basics.springin5steps.properties class SomeExternalService:
		
		@Component
		public class SomeExternalService {
	
			//from property file
			private String url;
	
			public String returnServiceURL() {
				return this.url;
			}
		}

	2. at src/main/resources, create app.properties file: 
		
		external.service.url=http://someserver.dev.com/service

	3. Go back to SomeExternalService and put: 
		
		@Value("${external.service.url}")
		private String url;

	4. To load the app.properties, create a new class SpringIn5StepsPropertiesApplication (@PropertySource("classpath:app.properties")):
		@Configuration
		@ComponentScan
		//load app.properties
		@PropertySource("classpath:app.properties")
		public class SpringIn5StepsPropertiesApplication {

			public static void main(String[] args) {
				try (AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext(
						SpringIn5StepsPropertiesApplication.class)) {

					SomeExternalService service = applicationContext.getBean(SomeExternalService.class);
					System.out.println(service);
				}
			}
		}
------------------------------------------------------------------------------
SECTION 6 - BASIC TOOLS AND FRAMEWORKS - JUNIT IN 5 STEPS
------------------------------------------------------------------------------
37 - Section Introduction - JUnit in 5 Steps
	@Before, @After, @BeforeClass etc...
	Code in: https://github.com/in28minutes/spring-master-class/tree/master/00-framework-tool-introductions/03.JUnit-Introduction-In-5-Steps

------------------------------------------------------------------------------
38 - Step 1: What is JUnit and Unit Testing
	Unit Testing is testing a specific code or a class, for the methods of the class. JUnit is a framework that will help you call these methods and check whether the output is as expected. One advantage of using JUnit is that it is automated, running every hour or whenever any change happen, being notified. JUnits can be run in Continuous Integrations like Jenkins. 
	Unit Testing falls under the suit of Automation Testing. The important thing about automation testing is that these can be run under continuous integration. 

------------------------------------------------------------------------------
39 - Step 2: First JUnit Project and Green Bar
	Create new Java Project junit-in-5-steps and class in package com.fabiano.junit;

		public class MyMath {
			int sum (int[] numbers) {
				int sum = 0;
				for (int n : numbers) {
					sum+=n;
				}
				return sum;
			}
		}
	How can we be sure that this method is working fine?
	Let's create a source folder of tests (Unit tests should be in a different folder compared to Production code! The test code must not be deployed)
		new source folder "test"
	Then create new JUnit Test Case (New JUnit 4 test) MyMathTest. In JUnit, absence of failure is success, be careful.

------------------------------------------------------------------------------
40 - Step 3: First Code and First Unit Test
	Let's test the MyMath.sum in the JUnit test case we previously created. Create method:
	
	public class MyMathTest {
	
		MyMath myMath = new MyMath();
	
		@Test
		public void sumWith3Numbers() {
			//check that result is 6
			assertEquals(6, myMath.sum(new int[] {1,2,3}));
		}
	
		@Test
		public void sumWith1Number() {
			assertEquals(4, myMath.sum(new int[] {4}));
		}
	}
------------------------------------------------------------------------------
41 - Step 4: Other assert methods
	Created AssertTest:

------------------------------------------------------------------------------
42 - Step 5: Important Annotations



















