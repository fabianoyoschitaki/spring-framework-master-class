What are the beans?
What are the dependencies of a bean?
Where to search for beans? => No need as SpringBootApplication scans package and subs

@Component (beans)
@Autowired (dependency)
@Primary (disambiguous component)

Older versions of Spring:
Setter Injection -> if dependency is optional
Constructor Injection -> if dependency is mandatory

You don't need a setter with the @Autowired, the value is set by reflection.
You can also autowire by name

@Autowired
@Primary
private SortAlgorithm sortAlgorithm;

@Autowired
private SortAlgorithm bubleSortAlgorithm;

@Primary has priority over the bean name.

13 - Autowiring in depth - @Qualifier annotation
	Another way is put
	@Qualifier both in the dependency class and the class which has the dependency. @Qualifier has priority over @Primary!
	use @Primary if you have a more efficient algorithm among all. In case you have to switch to the other one, you can use autowiring by name or @Qualifier.

14 - Scope of a bean - Prototype and Singleton
	Bean Scope (default singleton)
	- singleton: One instance per Spring Context
	- prototype: New bean whenever requested
	- request: One bean per HTTP request
	- session: One bean per HTTP session

23 - Complex Scope Scenarios of a Spring Bean - Mix Prototype and Singleton
	if PersonDAO is singleton and has JdbcConnection is prototype as dependency, the same jdbcConnection object will be returned. 
	So you have to create a proxy
	@Scope(value=ConfigurableBeanFactory.SCOPE_PROTOTYPE, proxyMode=ScopedProxyMode.TARGET_CLASS)

24 - Difference between Spring Singleton and GOF Singleton
	GOF - 1 instance per JVM, even if multiple applications are running in the same JVM, the same instance would be returned. 
	Spring - 1 instance per application context. If there are 5 application contexts in the same JVM, 5 different instances.
	
25 - Using Component Scan to scan for beans
	if you application is com.test, every sub package will be scanned for components.
	But if you have components say in com.abc, you have to add in the spring application:
	@ComponentScan("com.abc")
	
26 - Lifecycle of a Bean @PostConstruct and @PreDestroy (callback methods)
	when put @Component, the lifecycle of a bean is going to be managed by the spring IOC container.
	if you want to do certain things before being destroyed or after it was created;
	One of the first things that the IOC container does is autowire the dependencies. Then, call 
	@PostConstruct method after that. The @PreDestroy is similar, but it happens when the instance
	is in the process of being removed by the container. 

27 - Container and Dependency Injection (CDI)
	Java EE Dependency Injection Standard (JSR 330)
	Spring supports most annotations:
		@Inject (@Autowired)
		@Named (@Component & @Qualifier)
		@Singleton (defined a scope of Singleton)
	Similar to JPA and Hibernate, interface and implementation, CDI defines how to do dependency injection. 
	In order to use CDI, add to pom.xml, below spring-boot-starter:
	<dependency>
		<groupId>javax.inject</groupId>
		<artifactId>javax.inject</artifactId>
		<version>1</version>
	</dependency>
	
	When use CDI annotations or Spring annotations? CDI is a Java EE standard. You'd always stick to a standard, 
	like JPA instead of Hibernate. There's actually no good reasons why use one over each other... :P 
	Btw CDI offers really good flexibility tomorrow if you want to switch away from Spring as Dependency Injection Framework.
	
28 - Ignore SLF4J Errors in Step 19 - We will fix them in Step 20 
	As we start removing Spring Boot and bringing in Spring core in the next step, you would see
	
	A few SLF4J errors.
	Logging does not work
	Do not worry about them. We will fix them in Step 20.
	
29 - Removing Spring Boot in Basic Application
	How to use Spring without Spring Boot? Let's remove spring boot starter.  
	Change in pom.xml:
	<dependency>
		<groupId>org.springframework.boot</groupId>
		<artifactId>spring-boot-starter</artifactId>
	</dependency>
	to
	<dependency>
		<groupId>org.springframework</groupId>
		<artifactId>spring-core</artifactId>
	</dependency>

	<dependency>
		<groupId>org.springframework</groupId>
		<artifactId>spring-context</artifactId>
	</dependency>
	if you run SpringIn5StepsBasicApplication, you'll get an error because spring boot is not available when running.
	The reason why there are no compile errors is because:
	<dependency>
		<groupId>org.springframework.boot</groupId>
		<artifactId>spring-boot-starter-test</artifactId>
		<scope>test</scope>
	</dependency>
	which we will remove later.
	
	The first thing to get rid of this error is to initialize Application Context: 
		Change @SpringBootApplication to @Configuration (org.springframework.context.annotation.Configuration)
	
	Also, SpringApplication is from spring boot. 
		Change ApplicationContext applicationContext = SpringApplication.run(SpringIn5StepsBasicApplication.class, args);
		to ApplicationContext applicationContext = new AnnotationConfigApplicationContext(SpringIn5StepsBasicApplication.class);
		
	The other change is that we have to scan the package (which spring boot does by default)
		@ComponentScan("") or declare the package explicitly.
	
	We will get Caused by: java.lang.ClassNotFoundException: org.slf4j.LoggerFactory, so we add in pom.xml:
		<dependency>
			<groupId>org.slf4j</groupId>
			<artifactId>slf4j-api</artifactId>
		</dependency>

30 - Fixing minor stuff - Add Logback and Close Application Context
	We have to close the application context:
		from ApplicationContext applicationContext = new AnnotationConfigApplicationContext(SpringIn5StepsBasicApplication.class);
		to ApplicationContext applicationContext = new AnnotationConfigApplicationContext(SpringIn5StepsBasicApplication.class);
		
		applicationContext.close();
		
	Another way would be using Java 7 feature:
		try (AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext(
				SpringIn5StepsBasicApplication.class)) {
				
	The log wasn't working properly. This is because we added the slf4j-api but not the implementation. Let's use logback which Spring uses by default:
		SLF4J: Failed to load class "org.slf4j.impl.StaticLoggerBinder".
		SLF4J: Defaulting to no-operation (NOP) logger implementation
		SLF4J: See http://www.slf4j.org/codes.html#StaticLoggerBinder for further details.
	
	The implementation:
		<!-- SLF4J implementation -->
		<dependency>
			<groupId>ch.qos.logback</groupId>
			<artifactId>logback-classic</artifactId>
		</dependency>

31 - Defining Spring Application Context Using XML
	